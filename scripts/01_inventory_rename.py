#!/usr/bin/env python3\n\"\"\"\nScript for Phase 1: File Inventory & Renaming\n\nTasks:\n1. Scan a directory for Wild Kratts script PDFs.\n2. Extract season/episode/title information (requires robust parsing logic).\n3. Calculate checksums (MD5 or SHA256) for each file.\n4. Generate/update the manifest.csv file.\n5. Optionally, rename files to the standard format: Sxx/Eyy - Title.pdf\n   (Ensure output directory structure exists or is created).\n\"\"\"\n\nimport argparse\nimport hashlib\nimport os\nimport pathlib\nimport re\nimport pandas as pd\n\ndef calculate_checksum(file_path, hash_algo='sha256'):\n    \"\"\"Calculates the checksum of a file.\"\"\"\n    hasher = hashlib.new(hash_algo)\n    with open(file_path, 'rb') as file:\n        while chunk := file.read(4096):\n            hasher.update(chunk)\n    return hasher.hexdigest()\n\ndef parse_filename(filename):\n    \"\"\"Placeholder function to extract metadata from filename.\"\"\"\n    # TODO: Implement robust parsing logic based on actual filename patterns\n    # Example (very basic, needs improvement):\n    match = re.match(r'S(\d+)E(\d+) - (.*)\.pdf', filename, re.IGNORECASE)\n    if match:\n        season = int(match.group(1))\n        episode = int(match.group(2))\n        title = match.group(3).strip()\n        return season, episode, title\n    return None, None, None # Indicate parsing failure\n\ndef main():\n    parser = argparse.ArgumentParser(description='Inventory and optionally rename Wild Kratts PDF scripts.')\n    parser.add_argument('input_dir', type=pathlib.Path, help='Directory containing raw PDF scripts.')\n    parser.add_argument('--manifest', type=pathlib.Path, default='data/manifest.csv', help='Path to output/update manifest CSV file.')\n    # parser.add_argument('--output_dir', type=pathlib.Path, help='Directory to move/rename files into (optional).')\n    # parser.add_argument('--rename', action='store_true', help='Actually rename and move files.')\n    # parser.add_argument('--checksum_algo', default='sha256', choices=['md5', 'sha256'], help='Checksum algorithm to use.')\n    args = parser.parse_args()\n\n    if not args.input_dir.is_dir():\n        print(f\"Error: Input directory not found: {args.input_dir}\")\n        return\n\n    print(f\"Scanning directory: {args.input_dir}\")\n    script_data = []\n\n    for item in args.input_dir.rglob('*.pdf'): # Recursively find PDFs\n        if item.is_file():\n            filename = item.name\n            print(f\"  Processing: {filename}\")\n            season, episode, title = parse_filename(filename)\n            checksum = calculate_checksum(item)\n\n            if season is None:\n                print(f\"    Warning: Could not parse metadata from filename: {filename}\")\n\n            script_data.append({\n                'season': season,\n                'episode': episode,\n                'title': title,\n                'file_name': filename, # Original filename\n                'checksum': checksum\n                # Add 'original_path': str(item) if needed\n            })\n\n    if not script_data:\n        print(\"No PDF files found.\")\n        return\n\n    manifest_df = pd.DataFrame(script_data)\n\n    # Ensure output directory for manifest exists\n    args.manifest.parent.mkdir(parents=True, exist_ok=True)\n    manifest_df.to_csv(args.manifest, index=False)\n    print(f\"Manifest saved to: {args.manifest}\")\n\n    # TODO: Implement renaming logic if args.rename and args.output_dir are set\n    # This would involve:\n    # 1. Constructing the new path (e.g., output_dir / f\"S{season:02d}\" / f\"E{episode:02d} - {title}.pdf\")\n    # 2. Creating the season directory if needed.\n    # 3. Moving/renaming the file (os.rename or shutil.move).\n    # 4. Updating the manifest with the new filename/path.\n\nif __name__ == \"__main__\":\n    main()\n